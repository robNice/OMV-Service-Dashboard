name: Deploy live to OMV
on:
  push:
    branches: ["live"]
  workflow_dispatch: {}

jobs:
  deploy:
    runs-on: ["docker"]
    env:
      GIT_SSL_CAINFO: /etc/ssl/certs/omv-ca-bundle.crt
      SSL_CERT_FILE:  /etc/ssl/certs/omv-ca-bundle.crt

    steps:
      - name: "Sanity: CA & /deploy vorhanden?"
        run: |
          set -e
          echo "whoami/id:"; whoami || true; id
          [ -r /etc/ssl/certs/omv-ca-bundle.crt ] || (echo "CA-Bundle fehlt!"; exit 1)
          ls -ld /deploy || (echo "/deploy fehlt!"; exit 1)        

      - uses: actions/checkout@v4

      - name: "Sanity: ist /deploy vorhanden?"
        run: |
          set -e
          echo "whoami/id:"
          whoami || true; id
          echo "Mounts (grep /deploy):"
          cat /proc/self/mounts | grep '/deploy' || true
          ls -ld /deploy || (echo "/deploy fehlt – bitte container.options in /data/config.yaml prüfen."; exit 1)


      - name: Build repo file list
        shell: bash
        run: |
          set -euo pipefail
          REPO_LIST="/tmp/repo_list.txt"
          # Alle Pfade aus dem Repo relativ auflisten (ohne .git/.forgejo/Manifest)
          find . -mindepth 1 \
            -path './.git' -prune -o \
            -path './.forgejo' -prune -o \
            -name '.deploy-manifest.txt' -prune -o \
            -print \
          | sed -E 's|^\./||' | sort -u > "$REPO_LIST"
          echo "Repo items: $(wc -l < "$REPO_LIST")"




      - name: "Copy repo -> /deploy (no rsync, no tar)"
        shell: bash
        run: |
          set -euo pipefail
          SRC="."
          DST="/deploy"

          # 1) Ordnerstruktur im Ziel anlegen (ohne .git/.forgejo/Manifest)
          find "$SRC" -mindepth 1 \
            -path './.git' -prune -o \
            -path './.forgejo' -prune -o \
            -name '.deploy-manifest.txt' -prune -o \
            -type d -print0 \
          | xargs -0 -I{} mkdir -p "$DST/{}"

          # 2) Dateien kopieren/überschreiben, ohne Owner/Mode/Timestamps zu ändern
          find "$SRC" -mindepth 1 \
            -path './.git' -prune -o \
            -path './.forgejo' -prune -o \
            -name '.deploy-manifest.txt' -prune -o \
            -type f -print0 \
          | xargs -0 -I{} cp --parents --force --no-preserve=mode,ownership,timestamps "{}" "$DST"




      - name: Delete only previously-deployed-but-now-missing
        shell: bash
        run: |
          set -euo pipefail
          DST="/deploy"
          PREV_MAN="$DST/.deploy-manifest.txt"
          CUR_LIST="/tmp/repo_list.txt"

          # Erst ab dem 2. Deploy werden Löschungen geprüft
          if [ -f "$PREV_MAN" ]; then
            # sicherstellen, dass das alte Manifest sortiert ist
            sort -u "$PREV_MAN" -o "$PREV_MAN"
            # to_delete = (alt) minus (neu)
            comm -23 "$PREV_MAN" "$CUR_LIST" > /tmp/to_delete.txt || true

            if [ -s /tmp/to_delete.txt ]; then
              echo "Will remove $(wc -l < /tmp/to_delete.txt) paths that were previously deployed but are now gone in repo"
              while IFS= read -r rel; do
                [ -z "$rel" ] && continue
                tgt="$DST/$rel"
                # Nur entfernen, wenn der Pfad exakt existiert
                if [ -e "$tgt" ]; then
                  if [ -f "$tgt" ] || [ -L "$tgt" ]; then
                    rm -f -- "$tgt"
                  elif [ -d "$tgt" ]; then
                    # Verzeichnis nur löschen, wenn leer – sonst bleibt es (fremde Inhalte werden NICHT angerührt)
                    rmdir --ignore-fail-on-non-empty -- "$tgt" || true
                  fi
                fi
              done < /tmp/to_delete.txt
            else
              echo "Nothing to delete."
            fi
          else
            echo "No previous manifest found – first deploy, nothing to delete."
          fi

          # Neues Manifest schreiben (Liste der aktuell deployten Repo-Pfade)
          cp /tmp/repo_list.txt "$PREV_MAN"


      - name: Fetch Compose v2 (standalone)
        env:
          COMPOSE_VERSION: "2.29.7"
          DOCKER_CONFIG: "/tmp/.docker"
          HOME: "/tmp"
        run: |
          set -e
          mkdir -p "$DOCKER_CONFIG"
          mkdir -p /tmp/compose
          curl -fsSL -o /tmp/compose/docker-compose \
            "https://github.com/docker/compose/releases/download/v${COMPOSE_VERSION}/docker-compose-linux-x86_64"
          chmod +x /tmp/compose/docker-compose
          /tmp/compose/docker-compose version


      - name: "Mirror repo to host:/opt/omv-landingpage"
        shell: bash
        run: |
          set -euo pipefail
          # Alles aus dem aktuellen Workspace als TAR an einen Einweg-Container pipen,
          # der auf dem HOST das Zielverzeichnis /opt/omv-landingpage bind-mountet.
          tar -C "${GITHUB_WORKSPACE:-.}" -cf - . \
          | docker run --rm -i \
              -v /opt/omv-landingpage:/deploy \
              alpine:3 sh -ceu 'rm -rf /deploy/* && mkdir -p /deploy && tar -C /deploy -xf - && ls -la /deploy'

      - name: "Compose down+up at host:/opt/omv-landingpage"
        env:
          DOCKER_CONFIG: "/tmp/.docker"
          HOME: "/tmp"
          COMPOSE_VERSION: "2.29.7"
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$DOCKER_CONFIG"
          
          # compose als Container nutzen – spricht über den host-Docker-Socket
          docker run --rm \
            -v /opt/omv-landingpage:/workspace \
            -v /var/run/docker.sock:/var/run/docker.sock \
            docker/compose:${COMPOSE_VERSION} \
            -f /workspace/docker-compose.yml \
            -p omv-landingpage down --remove-orphans || true
          
          docker run --rm \
            -v /opt/omv-landingpage:/workspace \
            -v /var/run/docker.sock:/var/run/docker.sock \
            docker/compose:${COMPOSE_VERSION} \
            -f /workspace/docker-compose.yml \
            -p omv-landingpage up -d --build




